<?php
/**
 * PaymentInstrumentCard
 *
 * PHP version 5
 *
 * @category Class
 * @package  Incevio\Cybersource\CybersourceSDK
 * @author   Swaagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Incevio\Cybersource\CybersourceSDK Merged Spec
 *
 * All Incevio\Cybersource\CybersourceSDK API specs merged together. These are available at https://developer.cybersource.com/api/reference/api-reference.html
 *
 * OpenAPI spec version: 0.0.1
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Incevio\Cybersource\CybersourceSDK\Model;

use \ArrayAccess;

/**
 * PaymentInstrumentCard Class Doc Comment
 *
 * @category    Class
 * @package     Incevio\Cybersource\CybersourceSDK
 * @author      Swagger Codegen team
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class PaymentInstrumentCard implements ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'PaymentInstrumentCard';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = [
        'expirationMonth' => 'string',
        'expirationYear' => 'string',
        'type' => 'string',
        'issueNumber' => 'string',
        'startMonth' => 'string',
        'startYear' => 'string',
        'useAs' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerFormats = [
        'expirationMonth' => 'MM',
        'expirationYear' => 'YYYY',
        'type' => null,
        'issueNumber' => null,
        'startMonth' => 'MM',
        'startYear' => 'YYYY',
        'useAs' => null
    ];

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = [
        'expirationMonth' => 'expirationMonth',
        'expirationYear' => 'expirationYear',
        'type' => 'type',
        'issueNumber' => 'issueNumber',
        'startMonth' => 'startMonth',
        'startYear' => 'startYear',
        'useAs' => 'useAs'
    ];


    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = [
        'expirationMonth' => 'setExpirationMonth',
        'expirationYear' => 'setExpirationYear',
        'type' => 'setType',
        'issueNumber' => 'setIssueNumber',
        'startMonth' => 'setStartMonth',
        'startYear' => 'setStartYear',
        'useAs' => 'setUseAs'
    ];


    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = [
        'expirationMonth' => 'getExpirationMonth',
        'expirationYear' => 'getExpirationYear',
        'type' => 'getType',
        'issueNumber' => 'getIssueNumber',
        'startMonth' => 'getStartMonth',
        'startYear' => 'getStartYear',
        'useAs' => 'getUseAs'
    ];

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    public static function setters()
    {
        return self::$setters;
    }

    public static function getters()
    {
        return self::$getters;
    }





    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     * @param mixed[] $data Associated array of property values initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['expirationMonth'] = isset($data['expirationMonth']) ? $data['expirationMonth'] : null;
        $this->container['expirationYear'] = isset($data['expirationYear']) ? $data['expirationYear'] : null;
        $this->container['type'] = isset($data['type']) ? $data['type'] : null;
        $this->container['issueNumber'] = isset($data['issueNumber']) ? $data['issueNumber'] : null;
        $this->container['startMonth'] = isset($data['startMonth']) ? $data['startMonth'] : null;
        $this->container['startYear'] = isset($data['startYear']) ? $data['startYear'] : null;
        $this->container['useAs'] = isset($data['useAs']) ? $data['useAs'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = [];

        if (!is_null($this->container['expirationMonth']) && (strlen($this->container['expirationMonth']) > 2)) {
            $invalid_properties[] = "invalid value for 'expirationMonth', the character length must be smaller than or equal to 2.";
        }

        if (!is_null($this->container['expirationMonth']) && (strlen($this->container['expirationMonth']) < 2)) {
            $invalid_properties[] = "invalid value for 'expirationMonth', the character length must be bigger than or equal to 2.";
        }

        if (!is_null($this->container['expirationYear']) && (strlen($this->container['expirationYear']) > 4)) {
            $invalid_properties[] = "invalid value for 'expirationYear', the character length must be smaller than or equal to 4.";
        }

        if (!is_null($this->container['expirationYear']) && (strlen($this->container['expirationYear']) < 4)) {
            $invalid_properties[] = "invalid value for 'expirationYear', the character length must be bigger than or equal to 4.";
        }

        if ($this->container['type'] === null) {
            $invalid_properties[] = "'type' can't be null";
        }
        if (!is_null($this->container['issueNumber']) && (strlen($this->container['issueNumber']) > 2)) {
            $invalid_properties[] = "invalid value for 'issueNumber', the character length must be smaller than or equal to 2.";
        }

        if (!is_null($this->container['issueNumber']) && (strlen($this->container['issueNumber']) < 1)) {
            $invalid_properties[] = "invalid value for 'issueNumber', the character length must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['startMonth']) && (strlen($this->container['startMonth']) > 2)) {
            $invalid_properties[] = "invalid value for 'startMonth', the character length must be smaller than or equal to 2.";
        }

        if (!is_null($this->container['startMonth']) && (strlen($this->container['startMonth']) < 2)) {
            $invalid_properties[] = "invalid value for 'startMonth', the character length must be bigger than or equal to 2.";
        }

        if (!is_null($this->container['startYear']) && (strlen($this->container['startYear']) > 4)) {
            $invalid_properties[] = "invalid value for 'startYear', the character length must be smaller than or equal to 4.";
        }

        if (!is_null($this->container['startYear']) && (strlen($this->container['startYear']) < 4)) {
            $invalid_properties[] = "invalid value for 'startYear', the character length must be bigger than or equal to 4.";
        }

        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {

        if (strlen($this->container['expirationMonth']) > 2) {
            return false;
        }
        if (strlen($this->container['expirationMonth']) < 2) {
            return false;
        }
        if (strlen($this->container['expirationYear']) > 4) {
            return false;
        }
        if (strlen($this->container['expirationYear']) < 4) {
            return false;
        }
        if ($this->container['type'] === null) {
            return false;
        }
        if (strlen($this->container['issueNumber']) > 2) {
            return false;
        }
        if (strlen($this->container['issueNumber']) < 1) {
            return false;
        }
        if (strlen($this->container['startMonth']) > 2) {
            return false;
        }
        if (strlen($this->container['startMonth']) < 2) {
            return false;
        }
        if (strlen($this->container['startYear']) > 4) {
            return false;
        }
        if (strlen($this->container['startYear']) < 4) {
            return false;
        }
        return true;
    }


    /**
     * Gets expirationMonth
     * @return string
     */
    public function getExpirationMonth()
    {
        return $this->container['expirationMonth'];
    }

    /**
     * Sets expirationMonth
     * @param string $expirationMonth Two-digit month in which the credit card expires. Format: `MM` Possible values: `01` through `12`  This field is optional if your Incevio\Cybersource\CybersourceSDK account is configured for relaxed requirements for address data and expiration date. For more information about relaxed requirements, see the TMS REST API Developer Guide.  Important: It is your responsibility to determine whether a field is required for the transaction you are requesting.
     * @return $this
     */
    public function setExpirationMonth($expirationMonth)
    {
        if (!is_null($expirationMonth) && (strlen($expirationMonth) > 2)) {
            throw new \InvalidArgumentException('invalid length for $expirationMonth when calling PaymentInstrumentCard., must be smaller than or equal to 2.');
        }
        if (!is_null($expirationMonth) && (strlen($expirationMonth) < 2)) {
            throw new \InvalidArgumentException('invalid length for $expirationMonth when calling PaymentInstrumentCard., must be bigger than or equal to 2.');
        }

        $this->container['expirationMonth'] = $expirationMonth;

        return $this;
    }

    /**
     * Gets expirationYear
     * @return string
     */
    public function getExpirationYear()
    {
        return $this->container['expirationYear'];
    }

    /**
     * Sets expirationYear
     * @param string $expirationYear Four-digit year in which the credit card expires. Format: `YYYY`. Possible values: `1900` through `2099`.  **FDC Nashville Global and FDMS South** You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of the year.  This field is optional if your Incevio\Cybersource\CybersourceSDK account is configured for relaxed requirements for address data and expiration date. For details, see [Relaxed Requirements for Address Data and Expiration Date.](https://www.cybersource.com/developers/integration_methods/relax_avs/). **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.'
     * @return $this
     */
    public function setExpirationYear($expirationYear)
    {
        if (!is_null($expirationYear) && (strlen($expirationYear) > 4)) {
            throw new \InvalidArgumentException('invalid length for $expirationYear when calling PaymentInstrumentCard., must be smaller than or equal to 4.');
        }
        if (!is_null($expirationYear) && (strlen($expirationYear) < 4)) {
            throw new \InvalidArgumentException('invalid length for $expirationYear when calling PaymentInstrumentCard., must be bigger than or equal to 4.');
        }

        $this->container['expirationYear'] = $expirationYear;

        return $this;
    }

    /**
     * Gets type
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     * @param string $type Type of credit card. Possible values:   * **visa** -- Visa (001)   * **mastercard** -- Mastercard (002) - Eurocard—European regional brand of Mastercard   * **american express** -- American Express (003)   * **discover** -- Discover (004)   * **diners club** -- Diners Club (005)   * **carte blanche** -- Carte Blanche (006)   * **jcb** -- JCB (007)   * **optima** -- Optima (008)   * **twinpay credit** -- Twinpay Credit (011)   * **twinpay debit** -- Twinpay Debit (012)   * **walmart** -- Walmart (013)   * **enroute** -- EnRoute (014)   * **lowes consumer** -- Lowes consumer (015)   * **home depot consumer** -- Home Depot consumer (016)   * **mbna** -- MBNA (017)   * **dicks sportswear** -- Dicks Sportswear (018)   * **casual corner** -- Casual Corner (019)   * **sears** -- Sears (020)   * **jal** -- JAL (021)   * **disney** -- Disney (023)   * **maestro uk domestic** -- Maestro (024) - UK Domestic   * **sams club consumer** -- Sams Club consumer (025)   * **sams club business** -- Sams Club business (026)   * **bill me later** -- Bill me later (028)   * **bebe** -- Bebe (029)   * **restoration hardware** -- Restoration Hardware (030)   * **delta online** -- Delta (031) — use this value only for Ingenico ePayments. For other processors, use 001 for all Visa card types.   * **solo** -- Solo (032)   * **visa electron** -- Visa Electron (033)   * **dankort** -- Dankort (034)   * **laser** -- Laser (035)   * **carte bleue** -- Carte Bleue (036) — formerly Cartes Bancaires   * **carta si** -- Carta Si (037)   * **pinless debit** -- pinless debit (038)   * **encoded account** -- encoded account (039)   * **uatp** -- UATP (040)   * **household** -- Household (041)   * **maestro international** -- Maestro (042) - International   * **ge money uk** -- GE Money UK (043)   * **korean cards** -- Korean cards (044)   * **style** -- Style (045)   * **jcrew** -- JCrew (046)   * **payease china processing ewallet** -- PayEase China processing eWallet (047)   * **payease china processing bank transfer** -- PayEase China processing bank transfer (048)   * **meijer private label** -- Meijer Private Label (049)   * **hipercard** -- Hipercard (050) — supported only by the Comercio Latino processor.   * **aura** -- Aura (051) — supported only by the Comercio Latino processor.   * **redecard** -- Redecard (052)   * **elo** -- Elo (054) — supported only by the Comercio Latino processor.   * **capital one private label** -- Capital One Private Label (055)   * **synchrony private label** -- Synchrony Private Label (056)   * **costco private label** -- Costco Private Label (057)   * **mada** -- mada (060)   * **china union pay** -- China Union Pay (062)   * **falabella private label** -- Falabella private label (063)
     * @return $this
     */
    public function setType($type)
    {
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets issueNumber
     * @return string
     */
    public function getIssueNumber()
    {
        return $this->container['issueNumber'];
    }

    /**
     * Sets issueNumber
     * @param string $issueNumber Number of times a Maestro (UK Domestic) card has been issued to the account holder.
     * @return $this
     */
    public function setIssueNumber($issueNumber)
    {
        if (!is_null($issueNumber) && (strlen($issueNumber) > 2)) {
            throw new \InvalidArgumentException('invalid length for $issueNumber when calling PaymentInstrumentCard., must be smaller than or equal to 2.');
        }
        if (!is_null($issueNumber) && (strlen($issueNumber) < 1)) {
            throw new \InvalidArgumentException('invalid length for $issueNumber when calling PaymentInstrumentCard., must be bigger than or equal to 1.');
        }

        $this->container['issueNumber'] = $issueNumber;

        return $this;
    }

    /**
     * Gets startMonth
     * @return string
     */
    public function getStartMonth()
    {
        return $this->container['startMonth'];
    }

    /**
     * Sets startMonth
     * @param string $startMonth Month of the start of the Maestro (UK Domestic) card validity period. Format: `MM`. Possible values: `01` through `12`.
     * @return $this
     */
    public function setStartMonth($startMonth)
    {
        if (!is_null($startMonth) && (strlen($startMonth) > 2)) {
            throw new \InvalidArgumentException('invalid length for $startMonth when calling PaymentInstrumentCard., must be smaller than or equal to 2.');
        }
        if (!is_null($startMonth) && (strlen($startMonth) < 2)) {
            throw new \InvalidArgumentException('invalid length for $startMonth when calling PaymentInstrumentCard., must be bigger than or equal to 2.');
        }

        $this->container['startMonth'] = $startMonth;

        return $this;
    }

    /**
     * Gets startYear
     * @return string
     */
    public function getStartYear()
    {
        return $this->container['startYear'];
    }

    /**
     * Sets startYear
     * @param string $startYear Year of the start of the Maestro (UK Domestic) card validity period.  Format: `YYYY`. Possible values: `1900` through `2099`.
     * @return $this
     */
    public function setStartYear($startYear)
    {
        if (!is_null($startYear) && (strlen($startYear) > 4)) {
            throw new \InvalidArgumentException('invalid length for $startYear when calling PaymentInstrumentCard., must be smaller than or equal to 4.');
        }
        if (!is_null($startYear) && (strlen($startYear) < 4)) {
            throw new \InvalidArgumentException('invalid length for $startYear when calling PaymentInstrumentCard., must be bigger than or equal to 4.');
        }

        $this->container['startYear'] = $startYear;

        return $this;
    }

    /**
     * Gets useAs
     * @return string
     */
    public function getUseAs()
    {
        return $this->container['useAs'];
    }

    /**
     * Sets useAs
     * @param string $useAs Card Use As Field. Supported value of `pinless debit` only. Only for use with Pinless Debit tokens.
     * @return $this
     */
    public function setUseAs($useAs)
    {
        $this->container['useAs'] = $useAs;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\Incevio\Cybersource\CybersourceSDK\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\Incevio\Cybersource\CybersourceSDK\ObjectSerializer::sanitizeForSerialization($this));
    }
}


